# decK state-file format (decK) vs Kong DBless format (DBless)

## Use cases

The two formats serve different use cases:
- DBless: backup/restore format for Kong gateway. By means of the CLI commands `kong config db_export`
  and `kong config db_import`.
- decK: the decK fileformat is intended for human interaction and manual editing.

## Core format specification

There is no document specifying the exact format. Since Kong can handle custom plugins with their
own custom schemas, this can never be complete on a field level description.

The best available description can be generated by using the Kong CLI with the "init" command;
`kong config init <filename>` (default filename is `"kong.yml"`)

## Issues

- users expect the formats to be compatible (which they are not). There is no clear communication/documentation
  about the differences between the 2 formats.
- with only `decK` and `Kong` as the consumers of those files this was manageable. WIth the introduction of new
  tools that also intent to operate on the files a well defined format is desireable.
- The file version format is dictated by Kong DBLess. There is no flag to indicate that a file is either a decK
  or DBLess file. One would have to use heuristics to determine the type, which is brittle and not "declarative".

## Differences

### Metadata

The DBLess format specifies metadata fields (fieldnames starting with an underscore; `"_"`). It supports the
following metadata fields:

| Field | decK | DBLess | description
|-|-|-|-
| `_format_version` | yes | yes | the format of the file, only supported on the root-object in the file.
| `_transform` | yes| yes | whether field transforms should still be applied or not, only supported on the root-object in the file.
| `_comment` | no | yes | a string field supporting opaque data to be stored in the same file, to be ignored by Kong. This field can be present on any entity (including the root-object) in the file.
| `_ignore` | no | yes | an array field supporting opaque data to be stored in the same file, to be ignored by Kong. This field can be present on any entity (including the root-object) in the file.

### Explicit incompatibilities

Around the "Consumer groups" feature some fields have explicitly different names in both formats. See this [Jira ticket](https://konghq.atlassian.net/browse/FTI-4808?focusedCommentId=93327).

| decK | DBless | format |
|-|-|-|
| `consumer_groups.plugins` | `consumer_groups.consumer_group_plugins` | |
| `consumers.groups` | `consumers.consumer_group_consumers` | |
| `consumers.groups[].name` | `consumers.consumer_group_consumers[].consumer_group` | |


| DBless Entity | decK |
|-|-|
| `consumer_group_plugins` | Does not exist, they are sub-entries in `consumer_groups`. </br>*Note:* the target field is called `plugins` (and hence this is inconsistent with standard entity relations, since it is called `consumer_groups.consumer_group_plugins` in the DBless format). </br>So `consumer_group_plugins[*]` -> `consumer_groups[*].plugins[*]`.|
|| *Conversion*: </br>* rename `consumer_groups[*].consumer_group_plugins` to `consumer_groups[*].plugins` (possibly merge if it already exists) </br>* iterate over `consumer_group_plugins`, </br>* for each entry find the related `consumer_group` entry, </br>* append the entry to the `plugins` array in that entry (create array if it doesn't exist).|
|| *Issues*: to specify a plugin for a group, the group itself **must be defined in the same file** in the `decK` format (since it must be nested). With the Kong format one could simply only have the plugin in `consumer_group_plugins` but that one does not exist in the `decK` format.|
|||
| `consumer_group_consumers` | Does not exist, they are sub-entries in `consumers`. </br>*Note 1*: the target field is called `groups` (and hence this is inconsistent with standard entity relations, since this is a many-to-many relation which the DBLess relations are not allowed to be nested). </br>*Note 2*: the name is `groups` but by convention should have been `consumer_groups` (to match the foreign entity name) </br>*Note 3*: the foreign key entries are strings with an ID, but since this is many-to-many it is an array field</br>*Note 4*: the entries in the array should have been simple strings referencing an unique field in the `consumer_groups` table, by `id` or `name`, but for some unknown reason the entries are objects with a key `name` (possibly `id` could also work???, maybe even the entire entity?)|
|| *Conversion*: </br>* iterate over `consumer_group_consumers` </br>* for each entry find the related `consumer` </br>* create a `groups` array in the `consumer` object if it doesn't exist </br>* insert into the `groups` array a new object with a single key `name` and the value being `consumer_group_consumer.consumer`|
|| *Issues*: the consumer **must be defined in the same file** in the `decK` format (since group-membership is nested within consumer). With the Kong format one could simply only have the membership in `consumer_group_consumers` but that one does not exist in the `decK` format.|





an exported DBless file (simplified):
```yml
_transform: false
_format_version: '3.0'

consumer_groups:
- name: A-team

consumer_group_plugins:
- name: rate-limiting-advanced
  consumer_group: A-team
  config:
    limit:
    - 1000
    retry_after_jitter_max: 0
    window_size:
    - 3600
    window_type: sliding

consumers:
- username: tieske
  custom_id: tieske-custom
- username: foo
  custom_id: bar

consumer_group_consumers:
- consumer: tieske
  consumer_group: A-team
- consumer: foo
  consumer_group: A-team
```

and the same config via `decK dump`:
```yml
_format_version: "3.0"

consumer_groups:
- name: A-team
  plugins:
  - config:
      limit:
      - 1000
      retry_after_jitter_max: 0
      window_size:
      - 3600
      window_type: sliding
    name: rate-limiting-advanced

consumers:
- custom_id: bar
  groups:
  - name: A-team
  username: foo
- custom_id: tieske-custom
  groups:
  - name: A-team
  username: tieske
```
