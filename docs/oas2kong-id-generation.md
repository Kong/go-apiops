# ID generation

IDs are generated by using the UUIDv5 algorithm, with the DNS namespace. See https://www.rfc-editor.org/rfc/rfc4122.
This allows to create stable UUIDs.

A UUIDv5 is a SHA1 hash crammed into a UUID format. For the SHA1 we can use string inputs, which will be
added to the default namespace (DNS, `6ba7b810-9dad-11d1-80b4-00c04fd430c8`).

To create stable IDs we require the same consistent input to recreate them over and over again, and yet get the
same ID as output. The ID input is based on unique names

# Name generation

The IDs must be unique, as well as the names of many entities to prevent collisions.
To create those we use properties from the OpenAPI spec to generate unique names.

Note: all names will be 'slugified' to ensure illegal characters are removed.

# Best practices

* for a document name use the `--uuid-base` flag to set it in the pipeline.
  This will ensure a unique document ID (without having to trust the OpenAPI spec author).
* use Operation IDs in the OpenAPI spec. Operation IDs are already unique within on OpenAPI spec.
  By using the Operation IDs there will be no need to have Kong-specific knowledge (only the more
  general OpenAPI knowledge) when cross-referencing between systems.
* Be aware of unique slugified names; names "nino", "niño" and "nínò" all become "nino".
  See also the [recommendation on Operation ID by OpenAPI](https://swagger.io/specification/#operation-object)
* Apply linting rules to enforce Operation IDs being set, and validate the character sets used (previous two bullets).
* Choose your names carefully, changing them later will result in changed names and IDs that will have to propagate
  through your systems (if you depend on them for reporting or alerting for example).
* using `--uuid-base` and Operation IDs will generate rather straightforward names (as opposed to slugified
  versions of an actual path). These are then easier to reason about when applying changes on top of the
  generated files using JSON-path for example.



## Base names

These are the basenames constructed for the OpenAPI objects. From these, the Kong Entity names will be derived.

### Document name

The top level of any ID is the document. In any automated environment, many OpenAPI specs can be used
independently, and we have to ensure uniqueness within those.
For example, an Operation ID in an OpenAPI spec MUST be unique within that document. But this means that across multiple
documents the Operation IDs might overlap.

Hence the top level is the OAS document level. So how is the name derived? In order of precedence:

1. the command-line flag `--uuid-base`. This allows platform operators that do not necessarily trust input from developer
   teams to set their own unique document ID that they control.
2. the `x-kong-name` directive in the document root, if present
3. the `info.title` field, if present
4. a random ID (UUIDv4)

Options 3 and 4 are fallbacks and make for a nice first experience using the tools, but for production usage, one should
either use option 1 or 2. The difference is that option 2 requires that the developer team can be trusted.

This should be chosen carefully, since changing this top-level name, will impact all generated entity names derived from
the same document, as well as their IDs.

### Path name

The source for a `path` object name has the following precedence:

1. the `x-kong-name` directive on the path, if present
2. the path, where a non-empty path with a trailing slash (`/`) gets a `~` appended to distinguish it from the same
   path without a trailing slash.

The unique path name is then created as `[document-name] + "-" + [path-source]`

### Operation name

| x-kong-name | operation id | unique operation name
|-|-|-
| no | no | `[unique-path-name] + "-" + [method]`
| no | yes | `[document-name] + "-" + [operation id]`
| yes | no | `[document-name] + "-" + [x-kong-name]`
| yes | yes | `[document-name] + "-" + [x-kong-name]`

The recommended way here is to use the Operation ID (and no `x-kong-name`), since it is more likely that everybody
is familiar with that property (over the custom Kong properties). So it will be easier for users to cross-reference
between different names and systems.

## Entity names and IDs


### service names

Services are generated from "servers" blocks. These can be defined on multiple levels in the OpenAPI spec. Typical is to
have a single one in the root of the document, but they can occur elsewhere. For each "servers" block a new "service"
entity is created.
Additional: if a new `x-kong-service-defaults` or `x-kong-upstream-defaults` is specified on any of the lower levels, it
will also lead to a new service (and upstream) being created.

Service names and IDs will be generated like this:

| location | name | uuid input |
|-|-|-|
| root | `[document-name]` | `[document-name] + ".service"` |
| path | `[unique-path-name]` | `[unique-path-name] + ".service"` |
| operation | `[unique-operation-name]` | `[unique-operation-name] + ".service"` |


## upstream names

This is the same as the services, except that the UUIDs will be generated using a `".upstream"` postfix instead.

| location | name | uuid input |
|-|-|-|
| root | `[document-name]` | `[document-name] + ".upstream"` |
| path | `[unique-path-name]` | `[unique-path-name] + ".upstream"` |
| operation | `[unique-operation-name]` | `[unique-operation-name] + ".upstream"` |

## route names

The route name is the `[unique-operation-name]`, and its uuid input will be `[unique-operation-name] + ".route"`


## plugin names

Plugins have a fixed name, and will not get an `instance-name` assigned. They only get an ID.
The uuid input depends on the location where the plugin is defined and the entity it is attached to.
Note that even if the plugin is specified only once in the OpenAPI document, it might result in multiple instances
of that plugin (when new service or upstream entities are generated for example).

The UUID input is: `[entity-name] + ".plugin." + [plugin-name]`.
